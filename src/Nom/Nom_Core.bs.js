// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Seq = require("@line100/rescript-seq/src/Seq.bs.js");
var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var Slice = require("@line100/rescript-seq/src/Slice.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var Err = /* @__PURE__ */Caml_exceptions.create("Nom_Core.Err");

var TransformException = /* @__PURE__ */Caml_exceptions.create("Nom_Core.TransformException");

function identity(endErr, input, i) {
  if (!input) {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: endErr,
            _2: i
          };
  }
  var c = input._0;
  return {
          TAG: /* Pass */0,
          _0: Seq.cdr(c),
          _1: c.head,
          _2: i + 1 | 0
        };
}

function satisfy(test, err, input, i) {
  if (!input) {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: Curry._1(err, undefined),
            _2: i
          };
  }
  var c = input._0;
  if (Curry._1(test, c.head)) {
    return {
            TAG: /* Pass */0,
            _0: Seq.cdr(c),
            _1: c.head,
            _2: i + 1 | 0
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: Curry._1(err, Caml_option.some(c.head)),
            _2: i
          };
  }
}

function satisfyN(test, n, err, input, i) {
  var lst = Seq.take(input, n);
  if (lst) {
    if (Curry._1(test, lst)) {
      return {
              TAG: /* Pass */0,
              _0: Seq.drop(input, n),
              _1: lst,
              _2: i + n | 0
            };
    } else {
      return {
              TAG: /* Fail */1,
              _0: input,
              _1: Curry._1(err, lst),
              _2: i
            };
    }
  } else {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: Curry._1(err, undefined),
            _2: i
          };
  }
}

function isEnd(v, err, input, i) {
  if (input) {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: Curry._1(err, undefined),
            _2: i
          };
  } else {
    return {
            TAG: /* Pass */0,
            _0: input,
            _1: v,
            _2: i
          };
  }
}

function $$return(v, input, i) {
  return {
          TAG: /* Pass */0,
          _0: input,
          _1: v,
          _2: i
        };
}

function error(e, input, i) {
  return {
          TAG: /* Fail */1,
          _0: input,
          _1: e,
          _2: i
        };
}

function mapValue(p, f, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match._0,
            _1: Curry._1(f, match._1),
            _2: match._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  }
}

function mapError(p, f, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: Curry._1(f, match._1),
            _2: match._2
          };
  }
}

function map(p, fv, fe, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match._0,
            _1: Curry._1(fv, match._1),
            _2: match._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: Curry._1(fe, match._1),
            _2: match._2
          };
  }
}

function mapPassed(p, f, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return Curry._3(f, match._0, match._1, match._2);
  } else {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  }
}

function mapFailed(p, f, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  } else {
    return Curry._3(f, match._0, match._1, match._2);
  }
}

function bind(p, f, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return Curry._3(f, match._1, match._0, match._2);
  } else {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  }
}

function or(p1, p2, input, i) {
  var pass = Curry._2(p1, input, i);
  if (pass.TAG === /* Pass */0) {
    return pass;
  } else {
    return Curry._2(p2, input, i);
  }
}

function alt(lst, err) {
  var partial_arg = Curry._1(err, undefined);
  var p = List.fold_right(or, lst, (function (param, param$1) {
          return {
                  TAG: /* Fail */1,
                  _0: param,
                  _1: partial_arg,
                  _2: param$1
                };
        }));
  return function (input, i) {
    if (input) {
      return Curry._2(p, input, i);
    } else {
      return {
              TAG: /* Fail */1,
              _0: input,
              _1: Curry._1(err, undefined),
              _2: i
            };
    }
  };
}

function cons(p1, p2, input, i) {
  var match = Curry._2(p1, input, i);
  if (match.TAG !== /* Pass */0) {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  }
  var match$1 = Curry._2(p2, match._0, match._2);
  if (match$1.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match$1._0,
            _1: Seq.cons(match._1, {
                  TAG: /* Forced */0,
                  _0: match$1._1
                }),
            _2: match$1._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: match$1._0,
            _1: match$1._1,
            _2: match$1._2
          };
  }
}

function seq(lst) {
  return List.fold_right(cons, lst, (function (param, param$1) {
                return {
                        TAG: /* Pass */0,
                        _0: param,
                        _1: /* Nil */0,
                        _2: param$1
                      };
              }));
}

function listPrepend(p1, p2, input, i) {
  var match = Curry._2(p1, input, i);
  if (match.TAG !== /* Pass */0) {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  }
  var match$1 = Curry._2(p2, match._0, match._2);
  if (match$1.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match$1._0,
            _1: {
              hd: match._1,
              tl: match$1._1
            },
            _2: match$1._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: match$1._0,
            _1: match$1._1,
            _2: match$1._2
          };
  }
}

function list(lst) {
  return List.fold_right(listPrepend, lst, (function (param, param$1) {
                return {
                        TAG: /* Pass */0,
                        _0: param,
                        _1: /* [] */0,
                        _2: param$1
                      };
              }));
}

function tuple(p1, p2, input, i) {
  var match = Curry._2(p1, input, i);
  if (match.TAG !== /* Pass */0) {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: match._1,
            _2: match._2
          };
  }
  var match$1 = Curry._2(p2, match._0, match._2);
  if (match$1.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match$1._0,
            _1: [
              match._1,
              match$1._1
            ],
            _2: match$1._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: match$1._0,
            _1: match$1._1,
            _2: match$1._2
          };
  }
}

function tuple3(p1, p2, p3) {
  return function (param, param$1) {
    return bind(p1, (function (v1) {
                  return function (param, param$1) {
                    return bind(p2, (function (v2) {
                                  return function (param, param$1) {
                                    return bind(p3, (function (v3) {
                                                  var partial_arg = [
                                                    v1,
                                                    v2,
                                                    v3
                                                  ];
                                                  return function (param, param$1) {
                                                    return {
                                                            TAG: /* Pass */0,
                                                            _0: param,
                                                            _1: partial_arg,
                                                            _2: param$1
                                                          };
                                                  };
                                                }), param, param$1);
                                  };
                                }), param, param$1);
                  };
                }), param, param$1);
  };
}

function takeWhile(test, input, i) {
  var match = Slice.seqSplitWhile(input, test);
  var slice = match[0];
  return {
          TAG: /* Pass */0,
          _0: match[1],
          _1: slice,
          _2: i + slice[0] | 0
        };
}

function takeWhile1(test, err) {
  return function (input, i) {
    var match = takeWhile(test, input, i);
    if (match.TAG === /* Pass */0) {
      if (match._2 > i) {
        return {
                TAG: /* Pass */0,
                _0: match._0,
                _1: match._1,
                _2: i
              };
      } else {
        return {
                TAG: /* Fail */1,
                _0: input,
                _1: Curry._1(err, undefined),
                _2: i
              };
      }
    }
    throw {
          RE_EXN_ID: Err,
          _1: "unreachable",
          Error: new Error()
        };
  };
}

function reduceWhile(test, f, init, input, i) {
  var match = Seq.reduceWhile(input, test, f, init);
  return {
          TAG: /* Pass */0,
          _0: match[2],
          _1: match[0],
          _2: i + match[1] | 0
        };
}

function context(make, p, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match._0,
            _1: Curry._1(make, match._1),
            _2: match._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: match._0,
            _1: match._1,
            _2: i
          };
  }
}

function contextMapError(make, p, err, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG === /* Pass */0) {
    return {
            TAG: /* Pass */0,
            _0: match._0,
            _1: Curry._1(make, match._1),
            _2: match._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: Curry._1(err, [
                  match._0,
                  match._1,
                  match._2
                ]),
            _2: i
          };
  }
}

function contextTuple(make, p) {
  return function (param, param$1) {
    return context((function (param) {
                  return Curry._2(make, param[0], param[1]);
                }), p, param, param$1);
  };
}

function contextTuple3(make, p) {
  return function (param, param$1) {
    return context((function (param) {
                  return Curry._3(make, param[0], param[1], param[2]);
                }), p, param, param$1);
  };
}

function allConsuming(p, err, input, i) {
  var match = Curry._2(p, input, i);
  if (match.TAG !== /* Pass */0) {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: Curry._1(err, [
                  match._0,
                  match._1,
                  match._2
                ]),
            _2: i
          };
  }
  var rest = match._0;
  if (rest === /* Nil */0) {
    return {
            TAG: /* Pass */0,
            _0: rest,
            _1: match._1,
            _2: match._2
          };
  } else {
    return {
            TAG: /* Fail */1,
            _0: input,
            _1: Curry._1(err, undefined),
            _2: i
          };
  }
}

function transform(p, seq, i) {
  var match = Curry._2(p, seq, i);
  if (match.TAG === /* Pass */0) {
    var i0 = match._2;
    var rest = match._0;
    return Seq.cons(match._1, {
                TAG: /* Lazy */1,
                _0: (function (param) {
                    return transform(p, rest, i0);
                  })
              });
  }
  throw {
        RE_EXN_ID: TransformException,
        _1: i,
        Error: new Error()
      };
}

function transfromInPlace(p, s) {
  var next = function (param) {
    if (s.contents === /* Nil */0) {
      return /* Nil */0;
    }
    var match = Curry._2(p, s.contents, 0);
    if (match.TAG === /* Pass */0) {
      s.contents = match._0;
      return Seq.cons(match._1, {
                  TAG: /* Lazy */1,
                  _0: (function (param) {
                      return next(undefined);
                    })
                });
    }
    throw {
          RE_EXN_ID: TransformException,
          _1: 0,
          Error: new Error()
        };
  };
  return next(undefined);
}

exports.Err = Err;
exports.TransformException = TransformException;
exports.identity = identity;
exports.satisfy = satisfy;
exports.satisfyN = satisfyN;
exports.isEnd = isEnd;
exports.$$return = $$return;
exports.error = error;
exports.mapValue = mapValue;
exports.mapError = mapError;
exports.map = map;
exports.mapPassed = mapPassed;
exports.mapFailed = mapFailed;
exports.bind = bind;
exports.or = or;
exports.alt = alt;
exports.cons = cons;
exports.seq = seq;
exports.listPrepend = listPrepend;
exports.list = list;
exports.tuple = tuple;
exports.tuple3 = tuple3;
exports.takeWhile = takeWhile;
exports.takeWhile1 = takeWhile1;
exports.reduceWhile = reduceWhile;
exports.context = context;
exports.contextMapError = contextMapError;
exports.contextTuple = contextTuple;
exports.contextTuple3 = contextTuple3;
exports.allConsuming = allConsuming;
exports.transform = transform;
exports.transfromInPlace = transfromInPlace;
/* No side effect */
